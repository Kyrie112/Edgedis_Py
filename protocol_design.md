# 采用纠删码的分布式数据传输协议
## 节点状态信息(初步设置)
每个节点需要存储一系列字段，可以用于记录自身状态的同时，用于协议中的各项操作。
* 节点自身id：在信息发送时告诉信息接收者，是哪个节点向其发送信息
* 节点当前状态statues：用于记录节点时Follower、Candidate还是Leader
* 节点Leader_id：用于记录当前节点所在集群的Leader的id号
* 集群节点列表：发送信息、统计投票时需要使用这个信息
* 当前任期号Term：在开启投票以及投票判断中使用
* 投票对象Vote_for：此字段是一个hash table，用于记录不同Term节点投票节点id
* 数据块存储列表：此字段是一个hash table，用于记录不同数据块id对应的数据块
* 数据块信息列表：此字段是一个hash table，用于记录不同的不同的原始数据id对应的两个个编号，分别为编码块起始编号、原始数据编号，从而在之后的数据补发中可以较快查找数据块信息，从而进行数据块补发
* 数据块转发队列：当一个节点成为Sender时，会在将收到的<font color='color'>新数据</font>存储到存储列表的同时，存储到这个列表中，等待节点进行广播转发

## 数据传输方式
### 云端
当云端需要进行数据传输时，会首先按照一定的规则，对原始数据进行纠删码编码操作(假定编码后总块数为k，每个节点需要n个块即可将原始数据还原出来)，然后同时散布到一些选定的节点上(总数量为k)，让这些节点负责数据的转发操作。

在分发数据的同时，云端会开始统计发送出去的k个块的传输情况，当某一个入口节点完成了自己的数据块传输，会及时反馈到云端，云端收到反馈会将对应的块状态设置为已经完成发送。当云端发现发送出去的k个块有n个已经完成发送，则可以告诉用户，当前数据已经完成发送，可以开始下一次的数据发送。

需要注意，当云端收到了n个数据块完成发送的反馈后，仍然存在k-n个入口节点没有完成发送，此时需要让这些节点直接停下当前发送中的任务，开始下一次的数据发送，从而保证云端发送数据不会受到慢速节点的拖累。
### 边缘节点
在数据分发的过程中，边缘节点分为两类。一类是收到了云端发送过来的编码块的节点，一类是没有收到云端直接发送的数据块的节点，这两类节点需采用不同的角色进行区分，从而完成每个节点都能够获得目标数据的要求。
* 直接接受云端数据的节点：接收到数据后，立刻转换角色为Sender，准备开始进行数据块广播，将数据向节点集群中发送，等待其他的节点接受后的反馈。一旦发现数据块已经被一半以上的节点接收到就可以反馈给云端，自己的任务已经完成。如果云端开始下一个数据发送时需要立刻放弃当前任务，开始下一个数据块发送。
* 没有直接接收到云端数据的节点；接收到直接数据的节点状态为Receiver，需要等待其Sender的数据块发送，一旦收到了数据块，不论是否已经接收到，都需要告诉Sender自己已经接受到了数据。<font color="red">是否可以考虑在普通节点收到入口节点的消息后，也转变角色为Sub_Sender，继续广播数据，但是不需要向云端反馈</font>。
* 所有节点：由于采用的是纠删码编码的方式，一个节点不需要等待所有的数据块就可以将云端发送的原始数据发送出来，当一个节点接收到任意n个数据块时就可以将数据恢复出来；由于此时仍然存在慢速节点的数据延迟到达，此时仍然需要接受并给予反馈。

### 数据分发细节
* 数据块id对应方式以及节点存储数据方式：由于发送数据的过程中存在两种两种数据块，一种是原始的数据块，可以通过纠删码解码完成；另一种时编码后的数据，可以直接从Sender处(或者后续的Leader补发机制)获取，故可以将数据块和编码块一起存储。例如设起始块号为a，总块数为k，需要n个块可以还原出原始文件，则id号对应关系应有：[a,a+k-1]存储编码块，a+k存储原始数据
* 数据重发：当发送的k个数据块中，有大于k-n个块在超时前不能完成发送到集群中，需要云端进行数据重发操作，此时需要将需要重传的数据块发送到已经完成发送任务的入口节点上，让这些快速节点负责重新发送.
* 数据补发：补发发生有两个情况。1.Leader选举完成后，Leader需要向其他的节点寻求数据块，尽量的把每个Follower的数据块都能收集到(包括编码块也包括原始数据块)。2.当一个Follower发现自己相对Leader缺少数据时，需要通过向Leader请求数据块，从而保障自己能够收到所有云端当前已经发送的数据。具体的补发方式在之后的文档中会说明。

## 领导者选举
### 角色设计
除了之前的数据分发过程中的Sender和Receiver，对于保证数据的一致性，需要另外设计一套角色。
#### Follower
节点集群中大多数为此角色，其主要职责有一下几条：
* 处理Leader发送的心跳，并根据心跳中的信息，给当前的Leader补发数据
* 发现自己的数据没有Leader多时，向Leader发送请求，请求数据
* 当长时间没有收到心跳时，自身Term+1，变为Candidate状态
* 处理其他的C票andidate的投请求，且投票的条件为：1.当前Candidate的Term大于自己；2.自己在当前Term没有投过票；如果成功投票，需要更新自己的Term为Candidate的Term，并且同时重置自己的超时时间。(可以理解为投票的是先到先得，不需要根据其他条件)
* 当发现自己的获得票数大于当前集群大小的1/2，则成为Leader
#### Candidate
当节点长时间没有收到心跳时，就转变成这个状态，存在变成Leader的条件：
* 发起投票，并同时投票给自己
* 接受其他人的投票，如果发现票数已经大于集群大小的1/2则立即成为Leader
* 如果接收到其他Candidate的请求投票，发现比Term比自己大，则退化为Follower，并且给对方投票；否则不予处理
* 如果收到Leader的心跳，则退化成Follower，并且修改Term为信息中的Term
#### Leader
当一个节点收到了过半数的投票，则会有Candidate转化为Leader
* 当一个节点由Candidate变为Leader时，需要立刻向集群中的节点请求数据
* Leader需要定期发送心跳，并且通过这些心跳完成一系列任务(具体任务在后续文档中说明)
* Leader需要管理其他节点的数据补发
* Leader发现自己的数据不足时，需要向集群中的Follower节点请求信息

### 选举机制
考虑到与Edgedis中，节点需要根据Max_id选举Coordinator，将拥有数据量最大的节点设置为Coordinator。由于采用了纠删码之后，节点的Max_id并不能保证当前的节点拥有较多的数据块，有可能不能完成给其他的节点补发数据的任务。因此可以考虑直接根据节点的Term信息进行选举，然后开始向其他的节点请求数据，从而让当前节点具有能够给任何节点补发数据的能力。

## 消息类型
协议中存在各种消息类型，此部分对各种消息作用以及字段做分析
### 云端到入口节点消息
当云端需要发送数据时，需要将数据块发送到入口节点上，需要传递的信息仅包括编码后的数据块id。且需要注意的是当发送数据块的同时需要开启一个计时器，当超过一定时间后，需要开启数据重传。

### 入口节点到云端消息
当入口节点完成了自己负责数据块发送时，需要通知入口节点当前任务已完成，需要传递的消息是自己负责转发的数据块id。需要注意的是，只有集群中1/2以上的节点收到了自己负责的块时，才能向云端反馈。剩余没有收到的节点会由Leader的数据补发机制进行补发。<font color="red">若让所有的节点都有资格成为Sender，则可以所有的节点都可以向云端发送此种消息，任意一个节点发现数据完成发送，则可以向云端确认，从而加快转发速度</font>.

### 入口节点到其他节点数据传输消息
入口节点需要向其他的节点广播自己负责转发的数据，需要转发的信息是数据块id以及对应的数据块内容。发送后需要设置一个计时器，等待一定的时间没有接收到目标节点的响应时就需要进行数据重传。

### 其他节点到入口节点数据响应消息
普通节点接收到其他节点发送过来的消息后需要给予响应，需要告诉发送节点收到的数据块id。<font color="red">节点是否可以构建一个数据等待发送队列，当接收到一个新的数据时，就开始按照队列顺序对这个等待队列中的数据进行转发，从而通过减少重传加快传输</font>.

### 心跳
心跳是Leader保持身份的机制，在此协议中需要完成的除此之外，还可以完成数据补发任务。消息应包括以下内容：
* 自身节点id号，用于告诉集群中其他节点的Leader的id
* 自身的Term号，拥有让Candidate退化为Follower
* 自身拥有的数据块号列表，让收到心跳的Follower根据这个列表给其补发数据

### 心跳响应
心跳响应时除了Leader外的节点在处理心跳后返回的响应消息，在此协议中还可以用来让Follower给Leader进行数据补发操作，其需要的字段如下：
* 自身节点id号，用于告诉Leader已经收到了心跳的是哪一个节点
* 自身拥有的数据块列表号，可以让Leader检查其缺少数据块，从而进行数据补发
* 补发数据块，可以根据心跳中Leader的数据块号列表和自身的数据块列表，给Leader进行数据补发

### 投票请求
当Follower发现长时间没有收到心跳信息，需要转变为Candidate，开启投票，投票信息需要包括以下内容：
* 自身节点id号，告诉集群中是哪个节点开启投票
* 自身Term号，高举集群中请求投票节点的任期号

### 投票响应
Follower收到Candidate的投票请求，需要进行响应。其中包括以下内容：
* 自身节点id号，告诉Candidate是哪一个节点的投票
* 投票情况，支持就是True，否则为False

### Leader数据补发信息
由于Sender只需要保证1/2的节点已经收到了自己当前正在转发的数据就会通知云端开始下一次数据传输，所以可能存在有的节点由于网络延迟没有收到信息，所以需要通过Leader给这些节点进行数据补发，其中关键字段即为补发数据块字段，此处不需要节点响应(maybe?)，如果没有收到会在下一次心跳响应中检测到。

## 消息处理
此部分文档将会介绍各类节点如何处理上文消息类型中的各类消息的方法。

### 云端到入口节点消息处理
入口节点接收到消息后，将对应的数据块存储，并且记录其id，将这个数据块存储到自己的转发队列中，开始广播转发当前数据

### 入口节点到云端消息处理
当Sender发现大多数的节点(1/2)以上收到了当前信息，需要反馈到云端，云端记录当前数据块已经完成发送。

### 入口节点到普通节点数据传输消息处理
接受到消息后，普通节点会存储消息中的数据块，并同时反馈一个响应消息到发送节点。此时再检查是否已经获得到了n个数据块，如果是就可以开始解码获得原始数据。

<font color='font'>是否可以让当前节点同时成为一个Sender，并且将这个新消息存储到一个转发队列中，让这个节点也可以负责这个消息的转发，当发现集群中1/2以上的节点已经收到了之后也会给到云端一个消息反馈。</font>

### 普通节点到入口节点数据响应消息处理
Sender接收到Receiver的响应之后，需要记录对应的哪些节点已经收到了当前证字啊转发的数据块，如果大部分已经收到，则停止转发当前数据，向云端反馈当前的数据已经转发完成，取出数据转发队列中的下一个数据开始转发。

### 心跳处理
* Follower处理：更新自己的Leader_id,更新自己的Term与消息中的Term一致，并且根据消息中的数据列表和自己的数据列表，给Leader进行数据补发
* Candidate处理：退化为Follower，剩下的操作和Follower处理一致
  
### 心跳反馈处理
此消息只有Leader能处理，需要将心跳中的补发数据进行存储，如果已经收到了n个数据块则可以开始原始数据恢复，再根据心跳中的对应的Follower的缺少信息，进行数据补发，发送数据补发消息。

<font color='red'>补发数据时，尽量直接补发原始数据块，从而减少Follower的解码时间；如果Leader自己本身也缺少对应的原始数据块，则需要根据自身数据列表和心跳中的数据列表，补发消息列表中不包含的编码块(即对应的心跳的Follower节点缺少的编码块)，帮助对应的节点进行数据恢复。</font>

### 投票消息处理
Follower检查请求投票的Term，做出不同的处理(类似Raft，只考虑Term字段，并且按照先到先得的顺序投票)
* 消息中的Term比自己大，立即投票，并且设置自己的Vote_id为请求投票的Candidate的id，并且更新Term为消息中的Term
* 消息中的Term等于自己，检查自己在对应的Term中是否已经投过票，如果是则投出拒绝票

Leader接收到后，也会按照Follower的流程处理，但是会将自身的Term设置为消息中的Term+1，从而让Candidate退化为Follower，具体原因见投票反馈消息处理。
  
### 投票反馈消息处理
此消息只有Candidate处理，需要检查反馈消息中的Term和投票字段
* 如果发现反馈消息中的Term比自己大(说明当前集群中存在Leader)，立刻退化为Follower，并且更新自己的Term为消息中的Term
* 如果未发生以上情况，则将投票信息保存并检查是否存在半数以上的节点给自己投了赞同票；如果是则立刻转变为Leader同时广播心跳，开始收集数据
  
### 数据补发消息处理
此消息由Follower处理，Leader从心跳反馈中检查每个节点缺少的数据，Follower直接从补发消息中获取数据，检查是否已经获得足够的n个数据，如果是则开始解码，获得原始数据。

## 创新(初步考虑)
传输数据时，考虑让每一个节点都具备数据转发的能力，从而进一步加快数据传输以及单点失效的问题。正如前文所述，每个节点会有一个数据转发队列，节点会从中取数据进行数据转发。节点具体的操作有以下几点：

* 当一个节点收到了一个全新的数据块，将数据块保存到本地内存的同时，保存到数据的转发队列中，此时若数据转发队列为空，则立即开始转发，否则按照出队顺序将队列中的数据进行广播；若一个节点收到了自己已经拥有的数据时，此时数据不需要放入数据传输队列。
* 当一个节点发送的数据接收到了集群中半数以上的节点的接受反馈，则立刻向云端进行反馈，告知当前数据块已经完成转发；同时需要向集群中广播当前数据块转发已经完成的消息(此处称为数据发送完成消息，其包含对应完成转发数据的id号)
* 当一个节点接收到数据发送完成消息时，需要完成一系列操作。若节点正在转发的数据的id号与信息中的id号相同，则立刻停止转发数据，从数据传输队列中取下一个数据进行转发(若数据转发队列为空，则停止转发)；若节点正在转发其他数据，其需要检查自己的数据传输队列中是否存在此数据等待转发，若是则将这个数据块从队列中去除；对于没有进行数据转发的节点(即此节点没有转发数据且数据转发队列为空)，则不需要处理该消息。

引入此机制可能能够解决的问题有：
* 解决部分Sender在传输过程中存在失效(超过了纠删码容忍的错误数量)，从而导致云端在超时时间内无法收到足够的反馈，从而重传
* 部分Sender节点存在与云端之间带宽较小的问题，从而导致云端长时间无法收到反馈，从而重传
* 进一步提高数据传输的并行性，从以往的一个Sender负责一个数据的传输转变成多个Sender负责一个数据的传输

总结：让每个节点都能够转发数据以及与云端交互，一旦其发现某个数据已经完成了集群中的传播，则会及时告知云端并终止集群中其他节点对这个数据的传播
